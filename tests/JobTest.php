<?php

namespace TimurFlush\Queue\Tests;

use Phalcon\DiInterface;
use Phalcon\Events\ManagerInterface;
use TimurFlush\Queue\Exception;
use PHPUnit\Framework\TestCase;
use TimurFlush\Queue\AdapterInterface;
use TimurFlush\Queue\Job;
use TimurFlush\Queue\JobInterface;
use TimurFlush\Queue\Message;
use TimurFlush\Queue\MessageInterface;
use TimurFlush\Queue\Tests\Jobs\TestJob;
use Mockery as m;

class JobTest extends TestCase
{
    /**
     * @var \TimurFlush\Queue\Tests\Jobs\TestJob
     */
    protected $job;

    public function setUp()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->job = new TestJob();
        $this->job->setId(1);
    }

    public function testJobName()
    {
        $job = &$this->job;
        $jobName = 'someJob';
        $job->setJobName($jobName);
        $this->assertEquals($jobName, $job->getJobName(),
            sprintf('The value is: %s, expected: %s .', $job->getJobName(), $jobName)
        );
    }

    public function testDI()
    {
        $job = &$this->job;
        $di = m::mock(DiInterface::class);
        $job->setDI($di);
        $this->assertEquals($di, $job->getDI(), 'setDI()/getDI() is not working.');
    }

    public function testEventsManager()
    {
        $job = &$this->job;
        $manager = m::mock(ManagerInterface::class);
        $job->setEventsManager($manager);
        $this->assertEquals($manager, $job->getEventsManager(), 'setEventsManager()/getEventsManager() is not working.');
    }

    public function testConnection()
    {
        $job = &$this->job;
        $adapter = m::mock(AdapterInterface::class);
        $job->setConnection($adapter);
        $this->assertEquals($adapter, $job->getConnection(), 'setConnection()/getConnection() is not working.');
    }

    public function testGetTotalJobsInQueue()
    {
        $job = &$this->job;

        $total = rand(111, 999);

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('getTotalJobsInQueue')->andReturn($total);

        $job->setConnection($connectionMock);
        $this->assertEquals($total, $job->getTotalJobsInQueue(), 'getTotalJobsInQueue() is not working.');
    }

    public function testGetNextJob()
    {
        $job = &$this->job;

        $jobMock = m::mock(JobInterface::class);

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('getNextJob')->andReturn($jobMock);

        $job->setConnection($connectionMock);
        $this->assertEquals($jobMock, $job->getNextJob(), 'getNextJob() is not working.');
    }

    public function testOperationMade()
    {
        $job = &$this->job;

        $operation = Job::OP_SEND;
        $job->setOperationMade($operation);
        $this->assertEquals($operation, $job->getOperationMade(), 'setOperationMade/getOperationMade() is not working.');

        $operation = Job::OP_DELETE;
        $job->setOperationMade($operation);
        $this->assertEquals($operation, $job->getOperationMade(), 'setOperationMade/getOperationMade() is not working.');

        $operation = Job::OP_RELEASE;
        $job->setOperationMade($operation);
        $this->assertEquals($operation, $job->getOperationMade(), 'setOperationMade/getOperationMade() is not working.');

        $this->expectException(Exception::class);
        $job->setOperationMade(-1);
    }

    public function testAttemptDelay()
    {
        $job = &$this->job;

        $delay = rand(111, 999);
        $job->setAttemptDelay($delay);
        $this->assertEquals($delay, $job->getAttemptDelay(), 'setAttemptDelay()/getAttemptDelay() is not working.');

        $this->expectException(Exception::class);
        $job->setAttemptDelay(-1);
    }

    public function testGetMessages()
    {
        $job = &$this->job;

        $firstMessageMock = m::mock(MessageInterface::class);
        $firstMessageMock->shouldReceive('getMessage')->andReturn('firstMessageMock');
        $firstMessageMock->shouldReceive('getField')->andReturn('login');

        $secondMessageMock = m::mock(MessageInterface::class);
        $secondMessageMock->shouldReceive('getField')->andReturn('login');
        $secondMessageMock->shouldReceive('getMessage')->andReturn('secondMessageMock');

        $job->appendMessage($firstMessageMock);
        $job->appendMessage($secondMessageMock);

        $messages = $job->getMessages();
        foreach ($messages as $message) {
            $text = $message->getMessage();
            if ($text === 'firstMessageMock') {
                $this->assertEquals($text, $$text->getMessage(), 'appendMessage()/getMessages() is not working.');
            } elseif ($text === 'secondMessageMock') {
                $this->assertEquals($text, $$text->getMessage(), 'appendMessage()/getMessages() is not working.');
            }
        }

        $messages = $job->getMessages('login');
        foreach ($messages as $message) {
            $this->assertTrue($message->getField() === 'login', 'appendMessage()/getMessages(with filter) is not working.');
        }
    }

    public function testAutoPush()
    {
        $job = &$this->job;

        $ap = false;
        $job->setAutoPush(false);
        $this->assertEquals($ap, $job->getAutoPush(), 'setAutoPush()/getAutoPush() is not working.');

        $ap = rand(111, 999);
        $job->setAutoPush(true, $ap);
        $this->assertEquals($ap, $job->getAutoPush(), 'setAutoPush()/getAutoPush() is not working.');

        $this->expectException(Exception::class);
        $job->setAutoPush(true, -5);
    }

    public function testPriority()
    {
        $job = &$this->job;

        $priority = rand(111, 999);
        $job->setPriority($priority);
        $this->assertEquals($priority, $job->getPriority(), 'setPriority()/getPriority() is not working.');
    }

    public function testDelay()
    {
        $job = &$this->job;

        $delay = rand(111, 999);
        $job->setDelay($delay);
        $this->assertEquals($delay, $job->getDelay(), 'setDelay()/getDelay() is not working.');
    }

    public function testTtr()
    {
        $job = &$this->job;

        $seconds = rand(111, 999);
        $job->setTtr($seconds);
        $this->assertEquals($seconds, $job->getTtr(), 'setTtr()/getTtr() is not working.');

        $this->expectException(Exception::class);
        $job->setTtr(-1);
    }

    public function testQueuePrefix()
    {
        $job = &$this->job;

        $prefix = __METHOD__;
        $job->setQueuePrefix($prefix);
        $this->assertEquals($prefix, $job->getQueuePrefix(), 'setQueuePrefix()/getQueuePrefix() is not working.');
    }

    public function testQueueName()
    {
        $job = &$this->job;

        $name = __METHOD__;
        $job->setQueueName($name);
        $this->assertEquals($name, $job->getQueueName(), 'setQueueName()/getQueueName() is not working.');
    }

    public function testGetFullQueueName()
    {
        $job = &$this->job;

        $prefix = 'PREFIX_' . __METHOD__;
        $job->setQueuePrefix($prefix);
        $name = 'NAME_' . __METHOD__;
        $job->setQueueName($name);
        $this->assertEquals($prefix . $name, $job->getFullQueueName(), 'getFullQueueName() is not working.');

        $job->setAutoPush(true, 100);
        $this->assertEquals($prefix . $name . $job->getJobName(), $job->getFullQueueName(), 'getFullQueueName() is not working.');
    }

    public function testGetAttempts()
    {
        $job = &$this->job;

        $this->assertEquals(0, $job->getAttempts(), 'getAttempts()/incrementAttempt() is not working.');

        $job->incrementAttempt();
        $this->assertEquals(1, $job->getAttempts(), 'getAttempts()/incrementAttempt() is not working.');
    }

    public function testMaxAttemptsToDelete()
    {
        $job = &$this->job;

        $attempts = rand(111, 999);
        $job->setMaxAttemptsToDelete($attempts);
        $this->assertEquals($attempts, $job->getMaxAttemptsToDelete(), 'getMaxAttemptsToDelete()/setMaxAttemptsToDelete() is not working.');

        $this->expectException(Exception::class);
        $job->setMaxAttemptsToDelete(0);
    }

    public function testJobId()
    {
        $job = &$this->job;

        $id = rand(111, 999);
        $job->setJobId($id);
        $this->assertEquals($id, $job->getJobId(), 'getJobId()/setJobId() is not working.');

        $id = rand(1111, 9999);
        $job->setJobId($id);
        $this->assertFalse($job->getJobId() === $id, 'getJobId()/setJobId() is not working.');
    }

    public function testSleep()
    {
        $job = &$this->job;
        $resultProperties = $job->__sleep();
        $properties = (new \ReflectionObject($job))
            ->getProperties();
        foreach ($properties as $property) {
            $property->setAccessible(true);
            if (!is_callable($property->getValue($job)) && !is_object($property->getValue($job))) {
                $this->assertTrue(
                    in_array($property->getName(), $resultProperties),
                    'Property does not exists in __sleep() return.'
                );
            }
        }
    }
    public function testWakeup()
    {
        $job = &$this->job;
        /*
         * For test.
         */
        $job->setTtr(123);
        $job->setDelay(123);
        $expectedProperties = [];
        $properties = (new \ReflectionObject($job))
            ->getProperties();
        foreach ($properties as $property) {
            $property->setAccessible(true);
            if (!is_callable($property->getValue($job)) && !is_object($property->getValue($job))) {
                $expectedProperties[$property->getName()] = $property->getValue($job);
            }
        }
        $jobSleep = serialize($job);
        $jobWakedup = unserialize($jobSleep);
        $resultProperties = [];
        $properties = (new \ReflectionObject($jobWakedup))
            ->getProperties();
        foreach ($properties as $property) {
            $property->setAccessible(true);
            if (!is_callable($property->getValue($jobWakedup)) && !is_object($property->getValue($jobWakedup))) {
                $resultProperties[$property->getName()] = $property->getValue($jobWakedup);
            }
        }
        foreach ($expectedProperties as $name => $value) {
            $this->assertTrue(
                array_key_exists($name, $resultProperties) && $resultProperties[$name] === $expectedProperties[$name],
                sprintf('The property named %s was not found in the awakened object.', $name)
            );
        }
    }
    public function testSet()
    {
        $job = &$this->job;
        $this->expectException(Exception::class);
        $job->__set(__METHOD__, 5);
    }
    public function testGet()
    {
        $job = &$this->job;
        $this->expectException(Exception::class);
        $job->__get(__METHOD__);
    }
    public function testSetGet()
    {
        $job = &$this->job;
        $id = 5;
        $job->__set('id', $id);
        $this->assertEquals($id, $job->__get('id'), '__set()/__get() is not working.');
    }

    public function testIsExceededAttempts()
    {
        $job = &$this->job;

        $attempts = rand(111, 999);
        $attemptsToDelete = rand(111, 999);
        $job->setMaxAttemptsToDelete($attemptsToDelete);

        for ($i=0; $i < $attempts; $i++) {
            $job->incrementAttempt();
        }

        $this->assertEquals(($attemptsToDelete < $attempts), ($job->isExceededAttempts()), 'isExceededAttempts() is not working.');
    }

    public function testValidationHasFailed()
    {
        $job = &$this->job;

        $this->assertFalse($job->validationHasFailed(), 'validationHasFailed() is not working.');

        $job->appendMessage(new Message('someText'));
        $this->assertTrue($job->validationHasFailed(), 'validationHasFailed() is not working.');
    }

    public function isExists()
    {
        $job = &$this->job;

        $this->assertTrue(false, $this->isExists(), 'isExists() is not working.');

        $job->setJobId(15);

        $this->assertTrue(true, $this->isExists(), 'isExists() is not working.');
    }

    public function testSend()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(false);
        $job->setConnection($connectionMock);

        $this->assertFalse($job->send(), 'send() is not working.');

        $jobId = rand(111, 999);
        $connectionMock2 = m::mock(AdapterInterface::class);
        $connectionMock2->shouldReceive('send')->andReturn($jobId);

        $job->setConnection($connectionMock2);
        $job->setId(null);

        $send = $job->send();
        $this->assertFalse($send, 'send() is not working.');

        $job->setId(5);
        $send = $job->send([
            'ttr' => 1,
            'delay' => 1,
            'priority' => 1,
        ]);

        $this->assertTrue($send, 'send() is not working.');
        $this->assertEquals($jobId, $job->getJobId(), 'send() did not specify a job id.');
        $this->assertEquals($job::OP_SEND, $job->getOperationMade(), 'send() did not specify operation made.');

        $this->assertFalse($job->send(), 'Resending is not possible.');
    }

    public function testDelete()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('delete')->andReturn(true);

        $job->setConnection($connectionMock);

        $this->assertFalse($job->delete(), 'The job does not exist, cannot be deleted.');

        $job->send();
        $delete = $job->delete();

        $this->assertTrue($delete, 'delete() is not working.');
        $this->assertEquals($job::OP_DELETE, $job->getOperationMade(), 'delete() did not specify operation made.');

        if ($delete) {
            $this->assertFalse($job->delete(), 'Another deletion is impossible.');
        }

        $connectionMock2 = m::mock(AdapterInterface::class);
        $connectionMock2->shouldReceive('delete')->andReturn(false);

        $job->setConnection($connectionMock2);

        $this->assertFalse($job->delete(), 'delete() is not working.');
    }

    public function testRelease()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('release')->andReturn(true);
        $connectionMock->shouldReceive('delete')->andReturn(true);

        $job->setConnection($connectionMock);

        $job->send();

        $this->assertTrue($job->release(), 'release() is not working.');

        $connectionMock2 = m::mock(AdapterInterface::class);
        $connectionMock2->shouldReceive('release')->andReturn(false);
        $job->setConnection($connectionMock2);
        $this->assertFalse($job->release(), 'release() is not working.');
        $job->setConnection($connectionMock);
        $job->delete();

        $this->assertFalse($job->release(), 'release() is not working.');
        $this->assertEquals($job::OP_RELEASE, $job->getOperationMade(), 'release() did not specify operation made.');
    }

    public function testIsReleased()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('release')->andReturn(true);

        $job->setConnection($connectionMock);

        $job->send();
        $job->release();

        $this->assertTrue($job->isReleased(), 'isReleased() is not working.');
    }

    public function testIsDeleted()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('delete')->andReturn(true);

        $job->setConnection($connectionMock);

        $job->send();
        $job->delete();

        $this->assertTrue($job->isDeleted(), 'isDeleted() is not working.');
    }

    public function testIsCli()
    {
        $job = &$this->job;

        $this->assertTrue($job->isCli(), 'isCli() is not working.');
    }

    public function testFireEvent()
    {
        $job = &$this->job;

        $eventsManagerMock = m::mock(ManagerInterface::class);
        $eventsManagerMock->shouldReceive('fire')->andReturn(true);

        $job->setEventsManager($eventsManagerMock);

        $status = $job->fireEvent('someEventTrue');
        $this->assertTrue($status, 'fireEvent() is not working or someEvent() returns not true.');
    }

    public function testFireEventCancel()
    {
        $job = &$this->job;

        $status = $job->fireEventCancel('someEventTrue');
        $this->assertTrue($status,'fireEventCancel() is not working or someEvent() returns not true.');

        $status = $job->fireEventCancel('someEventFalse');
        $this->assertFalse($status, 'fireEventCancel() is not working or someEvent() returns not true.');

        $eventsManagerMock = m::mock(ManagerInterface::class);
        $eventsManagerMock->shouldReceive('fire')->andReturn(false);

        $job->setEventsManager($eventsManagerMock);

        $status = $job->fireEventCancel('someEvent');
        $this->assertFalse($status);
    }

    public function tearDown()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::tearDown(); // TODO: Change the autogenerated stub

        unset($this->job);
    }
}
