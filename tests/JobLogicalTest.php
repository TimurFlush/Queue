<?php

namespace TimurFlush\Queue\Tests;

use Phalcon\Events\ManagerInterface;
use PHPUnit\Framework\TestCase;
use TimurFlush\Queue\AdapterInterface;
use TimurFlush\Queue\JobInterface;
use TimurFlush\Queue\Message;
use TimurFlush\Queue\Tests\Jobs\TestJob;
use Mockery as m;

class JobLogicalTest extends TestCase
{
    /**
     * @var \TimurFlush\Queue\Tests\Jobs\TestJob
     */
    protected $job;

    public function setUp()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->job = new TestJob();
        $this->job->setId(1);
    }

    public function testIsExceededAttempts()
    {
        $job = &$this->job;

        $attempts = rand(111, 999);
        $attemptsToDelete = rand(111, 999);
        $job->setMaxAttemptsToDelete($attemptsToDelete);

        for ($i=0; $i < $attempts; $i++) {
            $job->incrementAttempt();
        }

        $this->assertEquals(($attemptsToDelete < $attempts), ($job->isExceededAttempts()), 'isExceededAttempts() is not working.');
    }

    public function testValidationHasFailed()
    {
        $job = &$this->job;

        $this->assertFalse($job->validationHasFailed(), 'validationHasFailed() is not working.');

        $job->appendMessage(new Message('someText'));
        $this->assertTrue($job->validationHasFailed(), 'validationHasFailed() is not working.');
    }

    public function isExists()
    {
        $job = &$this->job;

        $this->assertTrue(false, $this->isExists(), 'isExists() is not working.');

        $job->setJobId(15);

        $this->assertTrue(true, $this->isExists(), 'isExists() is not working.');
    }

    public function testSend()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(false);
        $job->setConnection($connectionMock);

        $this->assertFalse($job->send(), 'send() is not working.');

        $jobId = rand(111, 999);
        $connectionMock2 = m::mock(AdapterInterface::class);
        $connectionMock2->shouldReceive('send')->andReturn($jobId);

        $job->setConnection($connectionMock2);
        $job->setId(null);

        $send = $job->send();
        $this->assertFalse($send, 'send() is not working.');

        $job->setId(5);
        $send = $job->send([
            'ttr' => 1,
            'delay' => 1,
            'priority' => 1,
        ]);

        $this->assertTrue($send, 'send() is not working.');
        $this->assertEquals($jobId, $job->getJobId(), 'send() did not specify a job id.');
        $this->assertEquals($job::OP_SEND, $job->getOperationMade(), 'send() did not specify operation made.');

        $this->assertFalse($job->send(), 'Resending is not possible.');
    }

    public function testDelete()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('delete')->andReturn(true);

        $job->setConnection($connectionMock);

        $this->assertFalse($job->delete(), 'The job does not exist, cannot be deleted.');

        $job->send();
        $delete = $job->delete();

        $this->assertTrue($delete, 'delete() is not working.');
        $this->assertEquals($job::OP_DELETE, $job->getOperationMade(), 'delete() did not specify operation made.');

        if ($delete) {
            $this->assertFalse($job->delete(), 'Another deletion is impossible.');
        }

        $connectionMock2 = m::mock(AdapterInterface::class);
        $connectionMock2->shouldReceive('delete')->andReturn(false);

        $job->setConnection($connectionMock2);

        $this->assertFalse($job->delete(), 'delete() is not working.');
    }

    public function testRelease()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('release')->andReturn(true);
        $connectionMock->shouldReceive('delete')->andReturn(true);

        $job->setConnection($connectionMock);

        $job->send();

        $this->assertTrue($job->release(), 'release() is not working.');

        $connectionMock2 = m::mock(AdapterInterface::class);
        $connectionMock2->shouldReceive('release')->andReturn(false);
        $job->setConnection($connectionMock2);
        $this->assertFalse($job->release(), 'release() is not working.');
        $job->setConnection($connectionMock);
        $job->delete();

        $this->assertFalse($job->release(), 'release() is not working.');
        $this->assertEquals($job::OP_RELEASE, $job->getOperationMade(), 'release() did not specify operation made.');
    }

    public function testIsReleased()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('release')->andReturn(true);

        $job->setConnection($connectionMock);

        $job->send();
        $job->release();

        $this->assertTrue($job->isReleased(), 'isReleased() is not working.');
    }

    public function testIsDeleted()
    {
        $job = &$this->job;

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('send')->andReturn(rand(111, 999));
        $connectionMock->shouldReceive('delete')->andReturn(true);

        $job->setConnection($connectionMock);

        $job->send();
        $job->delete();

        $this->assertTrue($job->isDeleted(), 'isDeleted() is not working.');
    }

    public function testIsCli()
    {
        $job = &$this->job;

        $this->assertTrue($job->isCli(), 'isCli() is not working.');
    }

    public function testFireEvent()
    {
        $job = &$this->job;

        $eventsManagerMock = m::mock(ManagerInterface::class);
        $eventsManagerMock->shouldReceive('fire')->andReturn(true);

        $job->setEventsManager($eventsManagerMock);

        $status = $job->fireEvent('someEventTrue');
        $this->assertTrue($status, 'fireEvent() is not working or someEvent() returns not true.');
    }

    public function testFireEventCancel()
    {
        $job = &$this->job;

        $status = $job->fireEventCancel('someEventTrue');
        $this->assertTrue($status,'fireEventCancel() is not working or someEvent() returns not true.');

        $status = $job->fireEventCancel('someEventFalse');
        $this->assertFalse($status, 'fireEventCancel() is not working or someEvent() returns not true.');

        $eventsManagerMock = m::mock(ManagerInterface::class);
        $eventsManagerMock->shouldReceive('fire')->andReturn(false);

        $job->setEventsManager($eventsManagerMock);

        $status = $job->fireEventCancel('someEvent');
        $this->assertFalse($status);
    }

    public function tearDown()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::tearDown(); // TODO: Change the autogenerated stub

        unset($this->job);
    }
}
