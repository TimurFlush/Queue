<?php

namespace TimurFlush\Queue\Tests;

use Phalcon\Di;
use Phalcon\DiInterface;
use Phalcon\Events\Manager;
use Phalcon\Events\ManagerInterface;
use Phalcon\Queue\Beanstalk;
use PHPUnit\Framework\TestCase;
use TimurFlush\Queue\Adapter\Blackhole;
use TimurFlush\Queue\AdapterInterface;
use TimurFlush\Queue\Job;
use TimurFlush\Queue\JobInterface;
use TimurFlush\Queue\Message;
use TimurFlush\Queue\MessageInterface;
use TimurFlush\Queue\Tests\Jobs\TestJob;
use Mockery as m;

class JobSettersGettersTest extends TestCase
{
    /**
     * @var \TimurFlush\Queue\Job
     */
    protected $job;

    public function setUp()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->job = new TestJob();
    }
    
    public function testJobName()
    {
        $job = &$this->job;
        $jobName = 'someJob';
        $job->setJobName($jobName);
        $this->assertEquals($jobName, $job->getJobName(),
            sprintf('The value is: %s, expected: %s .', $job->getJobName(), $jobName)
        );
    }

    public function testDI()
    {
        $job = &$this->job;
        $di = m::mock(DiInterface::class);
        $job->setDI($di);
        $this->assertEquals($di, $job->getDI(), 'setDI()/getDI() is not working.');
    }

    public function testEventsManager()
    {
        $job = &$this->job;
        $manager = m::mock(ManagerInterface::class);
        $job->setEventsManager($manager);
        $this->assertEquals($manager, $job->getEventsManager(), 'setEventsManager()/getEventsManager() is not working.');
    }

    public function testConnection()
    {
        $job = &$this->job;
        $adapter = m::mock(AdapterInterface::class);
        $job->setConnection($adapter);
        $this->assertEquals($adapter, $job->getConnection(), 'setConnection()/getConnection() is not working.');
    }
    
    public function testGetTotalJobsInQueue()
    {
        $job = &$this->job;

        $total = rand(111, 999);

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('getTotalJobsInQueue')->andReturn($total);

        $job->setConnection($connectionMock);
        $this->assertEquals($total, $job->getTotalJobsInQueue(), 'getTotalJobsInQueue() is not working.');
    }
    
    public function testGetNextJob()
    {
        $job = &$this->job;

        $jobMock = m::mock(JobInterface::class);

        $connectionMock = m::mock(AdapterInterface::class);
        $connectionMock->shouldReceive('getNextJob')->andReturn($jobMock);

        $job->setConnection($connectionMock);
        $this->assertEquals($jobMock, $job->getNextJob(), 'getNextJob() is not working.');
    }

    public function testOperationMade()
    {
        $job = &$this->job;

        $operation = Job::OP_SEND;
        $job->setOperationMade($operation);
        $this->assertEquals($operation, $job->getOperationMade(), 'setOperationMade/getOperationMade() is not working.');
        
        $operation = Job::OP_DELETE;
        $job->setOperationMade($operation);
        $this->assertEquals($operation, $job->getOperationMade(), 'setOperationMade/getOperationMade() is not working.');

        $operation = Job::OP_RELEASE;
        $job->setOperationMade($operation);
        $this->assertEquals($operation, $job->getOperationMade(), 'setOperationMade/getOperationMade() is not working.');
    }

    public function testAttemptDelay()
    {
        $job = &$this->job;

        $delay = rand(111, 999);
        $job->setAttemptDelay($delay);
        $this->assertEquals($delay, $job->getAttemptDelay(), 'setAttemptDelay()/getAttemptDelay() is not working.');
    }

    public function testGetMessages()
    {
        $job = &$this->job;

        $firstMessageMock = m::mock(MessageInterface::class);
        $firstMessageMock->shouldReceive('getMessage')->andReturn('firstMessageMock');

        $secondMessageMock = m::mock(MessageInterface::class);
        $secondMessageMock->shouldReceive('getMessage')->andReturn('secondMessageMock');

        $job->appendMessage($firstMessageMock);
        $job->appendMessage($secondMessageMock);

        $messages = $job->getMessages();
        foreach ($messages as $message) {
            $text = $message->getMessage();
            if ($text === 'firstMessageMock') {
                $this->assertEquals($text, $$text->getMessage(), 'appendMessage()/getMessages() is not working.');
            } elseif ($text === 'secondMessageMock') {
                $this->assertEquals($text, $$text->getMessage(), 'appendMessage()/getMessages() is not working.');
            }
        }
    }

    public function testAutoPush()
    {
        $job = &$this->job;

        $ap = false;
        $job->setAutoPush(false);
        $this->assertEquals($ap, $job->getAutoPush(), 'setAutoPush()/getAutoPush() is not working.');

        $ap = rand(111, 999);
        $job->setAutoPush(true, $ap);
        $this->assertEquals($ap, $job->getAutoPush(), 'setAutoPush()/getAutoPush() is not working.');
    }

    public function testPriority()
    {
        $job = &$this->job;

        $priority = rand(111, 999);
        $job->setPriority($priority);
        $this->assertEquals($priority, $job->getPriority(), 'setPriority()/getPriority() is not working.');
    }

    public function testDelay()
    {
        $job = &$this->job;

        $delay = rand(111, 999);
        $job->setDelay($delay);
        $this->assertEquals($delay, $job->getDelay(), 'setDelay()/getDelay() is not working.');
    }

    public function testTtr()
    {
        $job = &$this->job;

        $seconds = rand(111, 999);
        $job->setTtr($seconds);
        $this->assertEquals($seconds, $job->getTtr(), 'setTtr()/getTtr() is not working.');
    }

    public function testQueuePrefix()
    {
        $job = &$this->job;

        $prefix = __METHOD__;
        $job->setQueuePrefix($prefix);
        $this->assertEquals($prefix, $job->getQueuePrefix(), 'setQueuePrefix()/getQueuePrefix() is not working.');
    }

    public function testQueueName()
    {
        $job = &$this->job;

        $name = __METHOD__;
        $job->setQueueName($name);
        $this->assertEquals($name, $job->getQueueName(), 'setQueueName()/getQueueName() is not working.');
    }

    public function testGetFullQueueName()
    {
        $job = &$this->job;

        $prefix = 'PREFIX_' . __METHOD__;
        $job->setQueuePrefix($prefix);
        $name = 'NAME_' . __METHOD__;
        $job->setQueueName($name);
        $this->assertEquals($prefix . $name, $job->getFullQueueName(), 'getFullQueueName() is not working.');

        $job->setAutoPush(true, 100);
        $this->assertEquals($prefix . $name . $job->getJobName(), $job->getFullQueueName(), 'getFullQueueName() is not working.');
    }

    public function testGetAttempts()
    {
        $job = &$this->job;

        $this->assertEquals(0, $job->getAttempts(), 'getAttempts()/incrementAttempt() is not working.');

        $job->incrementAttempt();
        $this->assertEquals(1, $job->getAttempts(), 'getAttempts()/incrementAttempt() is not working.');
    }

    public function testMaxAttemptsToDelete()
    {
        $job = &$this->job;

        $attempts = rand(111, 999);
        $job->setMaxAttemptsToDelete($attempts);
        $this->assertEquals($attempts, $job->getMaxAttemptsToDelete(), 'getMaxAttemptsToDelete()/setMaxAttemptsToDelete() is not working.');
    }

    public function testJobId()
    {
        $job = &$this->job;

        $id = rand(111, 999);
        $job->setJobId($id);
        $this->assertEquals($id, $job->getJobId(), 'getJobId()/setJobId() is not working.');
    }

    public function tearDown()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::tearDown(); // TODO: Change the autogenerated stub

        unset($this->job);
    }
}
