<?php

namespace TimurFlush\Queue\Tests;

use Phalcon\Di;
use Phalcon\DiInterface;
use Phalcon\Events\ManagerInterface;
use PHPUnit\Framework\TestCase;
use TimurFlush\Queue\AdapterInterface;
use TimurFlush\Queue\JobInterface;
use TimurFlush\Queue\Worker;
use Mockery as m;

class WorkerTest extends TestCase
{
    /**
     * @var \TimurFlush\Queue\Worker
     */
    public $worker = null;

    public function setUp()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->worker = new Worker();
    }

    public function testStopAfterHandledJobs()
    {
        $worker = &$this->worker;

        $worker->setStopAfterHandledJobs(15);
        $this->assertEquals(15, $worker->getStopAfterHandledJobs(), 'setStopAfterHandledJobs()/getStopAfterHandledJobs is not working.');
    }

    public function testEventsManager()
    {
        $worker = &$this->worker;

        $eventsManagerMock = m::mock(ManagerInterface::class);
        $worker->setEventsManager($eventsManagerMock);
        $this->assertEquals($eventsManagerMock, $worker->getEventsManager(), 'setEventsManager()/getEventsManager() is not working.');
    }

    public function testDI()
    {
        $worker = &$this->worker;

        $diMock = m::mock(DiInterface::class);
        $worker->setDI($diMock);
        $this->assertEquals($diMock, $worker->getDI(), 'setDI()/getDI() is not working.');
    }

    public function testMemoryLimit()
    {
        $worker = &$this->worker;

        $limit = rand(111, 999);
        $worker->setMemoryLimit($limit);
        $this->assertEquals($limit, $worker->getMemoryLimit(), 'setMemoryLimit()/getMemoryLimit() is not working.');
    }

    public function tearDown()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::tearDown(); // TODO: Change the autogenerated stub

        unset($this->worker);
    }
}

